# __LineCodeApi__

## __Description__

Yet another useless piece of software (at least it's not a TODO API :kekw:) to showcase my Go dev skills. LineCodeAPI provides an interface both Web (REST) and gRPC for generating and storing (in a database) __Line Codes__, a technique used to convert digital data in a pattern of analog signals. For instance, a Manchester line code represents logical zeros as a Rising Edge (-A to +A), and logical ones as a Falling Edge (+A to -A).

## Index

1. Get Started (EZ Docker Run)
2. App Architecture
3. Manchester Model
4. Domain Logic CODEC
5. Data Persistence with GORM
6. Web REST API with Gin
7. gRPC Server and Protobuf
8. Containerizing with Docker

## __1. Get Started__

This app can be easily run with Docker. An "example-docker-compose.yaml" file is provided inside the repo, copy the file as "docker-compose.yaml" and start it with docker compose.
```bash
cp example-docker-compose.yaml docker-compose.yaml
```
```bash
docker compose up
```

Once the app is running, the Web Server will be listening at:
```
localhost:8080
```
 With endpoints:
```
GET {{url}}/manchester
```
```
POST {{url}}/manchester/encoder

bodyExample = {
    "decoded": "0AE3",
    "decodedPulseWidth": 400,
    "unit": "us"
}
```

```
POST {{url}}/manchester/decoder

bodyExample = {
    "encoded": "-A+A+A-A+A-A+A-A+A-A+A-A+A-A-A+A",
    "encodedPulseWidth": 400,
    "unit": "us"
}
```

To test de gRPC API (listening on localhost:9000), I used __"grpc-cli"__ for my linux env (Arch btw):
```
grpc_cli ls localhost:9000

grpc_cli call localhost:9000 ManchesterEncode "decoded: '00E0FF', decodedPulseWidth: 200, unit: 'us'"

grpc_cli call localhost:9000 ManchesterDecode "encoded: '-A+A+A-A+A-A+A-A+A-A+A-A+A-A-A+A', decodedPulseWidth: 200, unit: 'us'"
```

But any gRPC client should work.

## __2. App Architecture__

This Software uses an Hexagonal Architecture with 3 concentric layers:
- __A core__ with domain logic and models (without dependencies)
- __An Application Layer__ with the __"ports"__ and the use cases.
- __An Adapters Layer__ with all the __"adapters"__ both driven an drivers!

Note: The domain logic is not connected through ports, it is injected (Dependency Injection) on the main func though.

Ports are implemented using Go interfaces, including de API port (not a Service but API on the wider definition) which is a "reversed port" required to connect the driver adapters to their respective use cases. Most ports are defined in the "ports.go" file but the gRPC port is auto-generated by Protobuf as a Service.

Adapters are Go structs that implement code with external dependencies, each one will be explained on further sections. All adapters should be instantiated in the app entrypoint (main file) and mounted with Dependency Injection.

## __3. Manchester Model__

There are a lot of line codes, this app (at the moment) provides a Manchester CODEC with a data model represented by the following JSON example:

```JSON
{
    "decoded": "AE01",
    "encoded": "+A-A-A+A+A-A-A+A+A-A+A-A+A-A-A+A-A+A-A+A-A+A-A+A-A+A-A+A-A+A+A-A",
    "decodedPulseWidth": 200,
    "encodedPulseWidth": 100,
    "unit": "ns"
}
```

Notice that:
- Decoded is a string of a hex representation of binary data. It __MUST__ be valid bytes!
- Encoded is the Manchester encoded data as a sequence of signal amplitudes (+A or -A) represented with a string.
- Both pulse widths represent the time duration of a signal pulse or digital data on a "clock" context.
- Unit is the time unit in seconds of the pulse width.

## __4. Domain Logic CODEC__

You may be wondering: Why would someone build such a useless API? (line codes are quite important but at Hardware lvl or Telecom)... Well idk, I was kinda out of ideas but hear me out, Go is LOVELY you can easily do low level stuff lik this CODEC with some powerful tools like hash maps!

### Manchester

The idea behind Manchester encoding is pretty easy:

```go
var in bool
in = getBit()
if in {
    return "+A-A"
} else {
    return "-A+A"
}
```

This works great on low level with perfect control of the CPU clock (or MicroController), as a Service maybe it is not the best idea to check every bit every time for every request!

Therefore, the app generates a byte (8 bit) grouping dictionary and stores it on RAM as a Go map. This is an efficient way to get the encoded pattern of a byte without looping, reducing time complexity from __O(n) to O(1)__, and consequently (with a chain of bytes) from __O(nÂ²) to O(n)__.

The dictionary constructing algorithm basically takes a byte and loops through this byte, it also uses a byte mask with an AND operator to check if a bit is set or cleared and appends the Manchester signal to the output.

Decoding uses the same aproach but reverted!

## __5. Data Persistence with GORM__

This Adapter uses GORM to communicate with a Postgres DataBase, on creation, a model migration is performed (Code First). Connection parameters are specified as OS Environmental Variables!

The driven adapter implements the database port interface and follows GORM's approach of passing model's pointers as arguments. Port methods should be reusable between data models.

Persistence should improve the app efficiency by searching the line code before creating it, avoiding unnecessary usage of the core logic.

## __6. Web REST API with Gin__

This is a driver Adapter, it runs a Web Server on port 8080 using Gin Framework and the application api port. The requests are handled with Gin's router.

Some notes:

- The adapter can be run with a go routine using the RunAsync Method, the main func should pass a wait group to sync the execution!
- A simple Postman collection is provided inside the repo with some examples of requests.
- Middleware can be added but it should be reserved for Gin framework dependent purposes only, like Auth.

## __7. gRPC Server and Protobuf__

This is also a driver Adapter that runs a server on port 9000, it uses Protobuf for go in order to generate the service code. The __"linecode_svc.proto"__ file contains both service and message types.

Some notes:

- The service interface is auto-generated and passed to the adapter through the __"UnimplementedLineCoderServer"__ (also auto-generated).
- Reflection is activated for testing with grpc-cli!
- The adapter can be run async (needed if you use several servers) with the RunAsync method, just like the REST API.

## __8. Containerizing with Docker__

A Dockerfile is included, inside:

- A Go with Alpine Linux image is pulled
- Source files are copied and dependencies are re-downloaded
- The app is built and the binary is properly relocated
- The app is executed through a simple entrypoint script that delays the init some seconds.

An example of "docker-compose.yaml" is also included, inside:

- A postgres DB image is pulled and run.
- The app container is built with OS env vars and link dependencies.
- A PGAdmin image is pulled and run for DB testing (this can be deleted).